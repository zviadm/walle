syntax = "proto3";
option go_package = "github.com/zviadm/walle/proto/walleapi";

service WalleApi {
	rpc ClaimWriter(ClaimWriterRequest) returns (ClaimWriterResponse) {}
	rpc WriterStatus(WriterStatusRequest) returns (WriterStatusResponse) {}
	rpc PutEntry(PutEntryRequest) returns (PutEntryResponse) {}

	// StreamEntries streams committed entries from a given starting point. StreamEntries
	// might exit early as long as it returns at least one successful entry. Note that
	// StreamEntries call will block until deadline, if there are no new committed
	// entries. Thus it can be used as a way to do long poll and stream latest entries from
	// a stream.
	rpc StreamEntries(StreamEntriesRequest) returns (stream Entry) {}
}

message Entry {
	int64 entry_id = 1;
	string writer_id = 2;
	bytes data = 3;
	// checksum_md5 is a rolling md5 for all `data`.
	bytes checksum_md5 = 4;
}

message ClaimWriterRequest {
	string stream_uri = 1;
	// Free form address that can be used to identify and reach this Writer.
	// Expected to be: <host>:<port> pair, but can be application specific.
	string writer_addr = 2;
	int64 lease_ms = 3;
}
message ClaimWriterResponse {
	string writer_id = 1;
	Entry last_entry = 2;
}

message WriterStatusRequest {
	string stream_uri = 1;
}
message WriterStatusResponse {
	string writer_addr = 1;
	int64 lease_ms = 2;
	int64 remaining_lease_ms = 3;
	int64 stream_version = 4;
}

message PutEntryRequest {
	string stream_uri = 1;
	Entry entry = 2;
	int64 committed_entry_id = 3;
	bytes committed_entry_md5 = 4;
}
message PutEntryResponse {
}

message StreamEntriesRequest {
	string stream_uri = 1;
	int64 from_entry_id = 2; // can be `-1` to stream last committed entry.
}

message Topology {
	// Matches EntryId of the stream it gets written to.
	int64 version = 1;
	// Maps streamURI -> StreamTopology
	map<string, StreamTopology> streams = 2;
	// Maps ServerID -> ServerInfo
	map<string, ServerInfo> servers = 3;
}

message StreamTopology {
	// Monotonically increasing `version` for the stream members.
	// StreamTopology at version `x` is compatible with topology at
	// version `x-1` and at version `x+1`. This allows seamless transition
	// between versions as long as majority of the members keep up.
	int64 version = 1;
	// Current serverIds for the stream.
	repeated string server_ids = 2;
	// ServerIds from `version-1` for the stream.
	repeated string prev_server_ids = 3;
}

message ServerInfo {
	string address = 1;
}